- name: Instalar MicroK8s, deploy whoami e stack de observabilidade
  hosts: all
  become: true
  vars:
    microk8s_channel: "1.34/stable"
    kubeconfig_path: /var/snap/microk8s/current/credentials/client.config
    app_namespace: apps
    whoami_ingress_host: "whoami.local"
    helm_chart_path: "charts/whoami"
    helm_release_name: "whoami"
  tasks:
    ########################################################################
    # Instalar snapd e MicroK8s
    ########################################################################
    - name: Instalar snapd se não existir
      ansible.builtin.package:
        name: snapd
        state: present
    - name: Instalar MicroK8s via snap
      ansible.builtin.snap:
        name: microk8s
        classic: yes
        channel: "{{ microk8s_channel }}"
        state: present
    ########################################################################
    # Detectar usuário atual
    ########################################################################
    - name: Detectar usuário que executa o playbook
      ansible.builtin.command: whoami
      register: current_user
      changed_when: false
    - name: Adicionar usuário atual ao grupo microk8s
      ansible.builtin.user:
        name: "{{ current_user.stdout }}"
        groups: microk8s
        append: yes
    # - name: Ajustar permissões do kubeconfig
    #   ansible.builtin.file:
    #     path: "{{ kubeconfig_path }}"
    #     owner: "{{ current_user.stdout }}"
    #     group: microk8s
    #     mode: '0640'
    ########################################################################
    # Habilitar addons essenciais
    ########################################################################
    - name: Aguardar MicroK8s estar pronto
      ansible.builtin.command: microk8s status --wait-ready
      changed_when: false
      timeout: 300
    - name: Habilitar addons essenciais (um por vez)
      ansible.builtin.command: "microk8s enable {{ item }}"
      loop:
        - dns
        - storage
        - metrics-server
        - ingress
      register: addon_result
      changed_when: "'is already enabled' not in addon_result.stdout"
      failed_when:
        - addon_result.rc != 0
        - "'is already enabled' not in addon_result.stdout"
    - name: Habilitar Observability
      ansible.builtin.command: microk8s enable observability
      register: obs_result
      changed_when: "'is already enabled' not in obs_result.stdout"
      failed_when: false
      ignore_errors: yes
    ########################################################################
    # Adicionar worker ao cluster (join)
    ########################################################################
    - name: Obter token de join do master
      ansible.builtin.command: microk8s add-node
      delegate_to: master
      run_once: true
      register: join_token
      changed_when: false
    ########################################################################
    #  Deploy da aplicação whoami
    ########################################################################
    - name: Criar diretório para helm charts no host remoto
      ansible.builtin.file:
        path: /tmp/helm-charts
        state: directory
        mode: '0755'
    - name: Copiar chart do whoami para o host remoto
      ansible.builtin.copy:
        src: ../charts/whoami/
        dest: /tmp/helm-charts/whoami/
        mode: '0755'
    - name: Instalar/Atualizar Helm release do whoami
      kubernetes.core.helm:
        name: whoami
        chart_ref: /tmp/helm-charts/whoami
        release_namespace: apps
        create_namespace: yes
        state: present
        kubeconfig: /var/snap/microk8s/current/credentials/client.config
        values:
          fullnameOverride: ""
          nameOverride: ""
          deployment:
            replicas: 2
            containers:
              - name: whoami
                image: containous/whoami
                pullPolicy: Always
                tag: latest
                namePort: http
                port: 80
              - name: metrics-sidecar
                image: nginx/nginx-prometheus-exporter
                pullPolicy: Always
                tag: 1.3.0
                port: 9112
                namePort: metrics
                scrapeUri: "http://127.0.0.1:80/"
          # metricsSidecar:
          #   enabled: true
          #   image:
          #     repository: nginx/nginx-prometheus-exporter
          #     tag: "1.3.0"
          #   port: 9112
          #   scrapeUri: "http://127.0.0.1:80/"
          service:
            type: ClusterIP
            port: 80
            metricsPort: 9112
            targetPort: 8080
          ingress:
            enabled: true
            ClassName: nginx
            annotations:
              cert-manager.io/cluster-issuer: letsencrypt-staging
            hosts:
              - host: whoami.local
                paths:
                  - path: /
                    pathType: Prefix
                    port: 80
            tls:
              enabled: true
              secretName: whoami-tls
          resources:
            limits:
              cpu: 100m
              memory: 128Mi
            requests:
              cpu: 100m
              memory: 128Mi
          monitoring:
            enabled: true
            interval: 15s
            release: kube-prom-stack
          labels:
            environment: production
          hpa:
            enabled: true
            minReplicas: 2
            maxReplicas: 4
            targetCPUUtilizationPercentage: 80
            targetMemoryUtilizationPercentage: 80
            behavior:
              scaleUp:
                stabilizationWindowSeconds: 5 # tempo em segundos para observar antes de aumentar
                selectPolicy: Max # pode ser Max, Min ou Disabled
                policies:
                  - type: Percent
                    value: 100 # Pode ser Percent ou Pods. É o Percentual ou número de pods aumentar de uma vez
                    periodSeconds: 60 # período em segundos para aplicar a política
                  - type: Pods
                    value: 4 # Pode ser Percent ou Pods. É o Percentual ou número de pods aumentar de uma vez
                    periodSeconds: 60 # período em segundos para aplicar a política
              scaleDown:
                stabilizationWindowSeconds: 300
                selectPolicy: Min
                policies:
                  - type: Percent
                    value: 100
                    periodSeconds: 15
                  - type: Pods
                    value: 4
                    periodSeconds: 15
        # replicaCount: 2
        # image:
        #   repository: containous/whoami
        #   tag: latest
        # ingress:
        #   enabled: true
        #   host: "{{ whoami_ingress_host }}"
        #   annotations:
        #     cert-manager.io/cluster-issuer: letsencrypt-staging
        # autoscaling:
        #   enabled: true
        #   minReplicas: 2
        #   maxReplicas: 5
        #   targetCPUUtilizationPercentage: 70
        # monitoring:
        #   enabled: true
        #   release: kube-prom-stack
        wait: true
        wait_timeout: 5m
    ########################################################################
    # Garantir CRD PodMonitor
    ########################################################################
    - name: Verificar se CRD PodMonitor existe
      kubernetes.core.k8s_info:
        kubeconfig: "{{ kubeconfig_path }}"
        kind: CustomResourceDefinition
        name: podmonitors.monitoring.coreos.com
      register: podmonitor_crd_info
      failed_when: false
    - name: Baixar CRD PodMonitor se não existir
      ansible.builtin.get_url:
        url: https://raw.githubusercontent.com/prometheus-operator/prometheus-operator/main/example/prometheus-operator-crd/monitoring.coreos.com_podmonitors.yaml
        dest: /tmp/monitoring.coreos.com_podmonitors.yaml
        mode: '0644'
      when: podmonitor_crd_info.resources | length == 0
    - name: Aplicar CRD PodMonitor
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig_path }}"
        state: present
        src: /tmp/monitoring.coreos.com_podmonitors.yaml
      when: podmonitor_crd_info.resources | length == 0
    ########################################################################
    # Cert-Manager + Let's Encrypt
    ########################################################################
    - name: Habilitar cert-manager no MicroK8s
      ansible.builtin.command: microk8s enable cert-manager
      changed_when: true
      check_mode: no
    - name: Criar ClusterIssuer Let's Encrypt (staging)
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig_path }}"
        state: present
        definition:
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: letsencrypt-staging
          spec:
            acme:
              server: https://acme-staging-v02.api.letsencrypt.org/directory
              email: "carlosleosouza@gmail.com"
              privateKeySecretRef:
                name: letsencrypt-staging
              solvers:
                - http01:
                    ingress:
                      class: nginx
    # ########################################################################
    # # Ingress para whoami com TLS
    # ########################################################################
    # - name: Criar Ingress para whoami com TLS
    #   kubernetes.core.k8s:
    #     kubeconfig: "{{ kubeconfig_path }}"
    #     state: present
    #     definition:
    #       apiVersion: networking.k8s.io/v1
    #       kind: Ingress
    #       metadata:
    #         name: whoami-ingress
    #         namespace: "{{ app_namespace }}"
    #         annotations:
    #           cert-manager.io/cluster-issuer: letsencrypt-staging
    #       spec:
    #         ingressClassName: nginx
    #         rules:
    #           - host: "{{ whoami_ingress_host }}"
    #             http:
    #               paths:
    #                 - path: /
    #                   pathType: Prefix
    #                   backend:
    #                     service:
    #                       name: "{{ app_name }}-svc"
    #                       port:
    #                         number: 80
    #         tls:
    #           - hosts:
    #               - "{{ whoami_ingress_host }}"
    #             secretName: whoami-tls
    ########################################################################
    # NodePorts para observabilidade
    ########################################################################
    - name: Garantir Grafana como NodePort
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig_path }}"
        state: present
        definition:
          apiVersion: v1
          kind: Service
          metadata:
            name: grafana
            namespace: observability
          spec:
            type: NodePort
            selector:
              app.kubernetes.io/name: grafana
            ports:
              - port: 3000
                targetPort: 3000
    - name: Garantir Prometheus como NodePort
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig_path }}"
        state: present
        definition:
          apiVersion: v1
          kind: Service
          metadata:
            name: prometheus
            namespace: observability
          spec:
            type: NodePort
            selector:
              app.kubernetes.io/name: prometheus
            ports:
              - port: 9090
                targetPort: 9090
    - name: Garantir Alertmanager como NodePort
      kubernetes.core.k8s:
        kubeconfig: "{{ kubeconfig_path }}"
        state: present
        definition:
          apiVersion: v1
          kind: Service
          metadata:
            name: alertmanager
            namespace: observability
          spec:
            type: NodePort
            selector:
              app.kubernetes.io/name: alertmanager
            ports:
              - port: 9093
                targetPort: 9093
    - name: Configurar NodePorts fixos para serviços de observabilidade
      ansible.builtin.command: >
        microk8s kubectl patch svc {{ item.name }} -n observability -p '{"spec": {"type": "NodePort","ports":[{"port":{{ item.port }},"targetPort":{{ item.targetPort }},"nodePort":{{ item.nodePort }}}]}}'

      loop:
        - {name: grafana, port: 3000, targetPort: 3000, nodePort: 32000}
        - {name: prometheus, port: 9090, targetPort: 9090, nodePort: 30900}
        - {name: alertmanager, port: 9093, targetPort: 9093, nodePort: 30903}
        - {name: loki, port: 3100, targetPort: 3100, nodePort: 31000}
      ignore_errors: yes
    ########################################################################
    # Exibir NodePorts
    ########################################################################
    - name: Obter todos os serviços do namespace observability
      kubernetes.core.k8s_info:
        kubeconfig: "{{ kubeconfig_path }}"
        kind: Service
        namespace: observability
      register: observability_services
    - name: Mostrar NodePorts dos serviços de observabilidade
      debug:
        msg: |
          {% for svc in observability_services.resources %}
          Serviço: {{ svc.metadata.name }}
          {% for port in svc.spec.ports %}
            Porta: {{ port.port }} → NodePort: {{ port.nodePort | default('não definido') }}
          {% endfor %}
          {% endfor %}
